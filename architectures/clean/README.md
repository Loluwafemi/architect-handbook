# Clean Architecture

> Reference: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

* Formal Definition.
* Generalization of Clean Architectures
* Dependency Rule
* Only Four Circles?
* Crossing Boundaries
* What data crosses the boundaries

## Formal Definition

The Clean Architecture style aims for a loosely coupled implementation focused on use cases and it is summarized as:

1. It is an architecture style where the _Use Cases_ are the centran organizing structure.

2. Follows the _Ports and Adapters_ pattern.
  * Implementation guided by tests (TDD Outside-In).
  * Decoupled from technology details.

3. Follows lots of principles (_Dependency Rule_, _Stable Abstractions Principle_, _Stable Dependencies Principle_, _SOLID_, and so on).

![Clean Architecture](./CleanArchitecture.jpg)

By separating the software into layers, and conforming to _The Dependency Rule_, you will create a system that is intrinsically testable, with all the benefits that implies. When any of the external parts of the system become obsolte, you can replace those with a minimum of fuss.

## Generalization of Clean Architectures

> * __Hexagonal Architecture (Ports and Adapters)__ by Alistair Cockburn and adopted by Steve Freeman, and Nat Pryce in their book _Growing Object Oriented Software_.
> * __Onion Architecture__ by Jeffrey Palermo.
> * __Screaming Architecture__ from Robert C Martin.
> * __DCI__ from James Coplien, and Trygve Reenskaug.
> * __BCE__ by Ivar Jacobson from his book _Object Oriented Software Engineering: A Use-Case Driven Approach_.

Though architectures all vary somewhat in their details, they are very similar. They all have the same objective, which is the separation of concerns. They all achieve this separation by dividing the software into layers. Each has at least one layer for business rules, and another for interfaces.

Each of these architectures produce systems that are:

1. __Independent of Frameworks__. The architecture does not depend on the existence of some library of feature laden software. This allows you to use such frameworks as tools, rather than having to cram your system into their limited constraints.

2. __Testable__. The business rules can be tested without the UI, Database, Web Server, or any other external element.

3. __Independent of UI__. The UI can change easily, without changing the rest of the system. A Web UI could be replaced with a console UI, for example, without changing the business rules.

4. __Independent of Database__. You can swap out Oracle or SQL Server, for Mongo, BigTable, CouchDB, or something else. Your business rules are not bound to the database.

5. __Independent of any external agency__. In fact your business rules simply donâ€™t know anything at all about the outside world.

## The Dependency Rule

The concentric circles represent different areas of software. In general, __the further in you go, the higher level the software becomes__.

> The outer circles are mechanisms. The inner circles are policies.

The _Dependency Rule_ is te __overriding rule that makes this architecture work__. This rule says that:

> Source code dependencies only point inwards. Nothing in an inner circle an know anything at all about something in an outer circle.

In particular, the name of something declared in an outer circle must not be mentioned by the code in an inner circle. By the same token, data formats used in an outer circle should not be used by an inner circle, especially if those formats are generated by a framework in an outer circle. __We don't want anything in an outer circle to impact the inner circles__.

> As you move inwards the level of abstraction increases. The outermost circle is low level concrete detail. As you move inwards the software grows more abstract, and encapsulates higher level policies. The inner most circle is the most general.

## Only Four Circles?

No, the circles are schematic. You may fin that you need more than just these four. However, __The Dependency Rule always applies__. Source code dependencies always point inwards.

## Crossing Boundaries

At the lower right of the diagram is an example of how we cross the circle boundaries. It shows the _Controllers_ and _Presenters_ communicating with the _Use Cases_ in the next layer. It begins in the controller, moves through the use case, and then winds up executing in the presenter. Note also the source code dependencies. Each one points inwards towards the use cases.

> We usually resolve this apparent contradiction by using the __Dependency Inversion Principle__.

In a language like Java, for example, we would arrange interfaces and inheritance relationships such that the source code dependencies oppose the flow of control at just the right points across the boundary.

> For example, consider that the use case needs to call the presenter. However, this call must not be direct because that would violate _The Dependency Rule_. No name in an outer circle can be mentioned by an inner circle. So we have the use case call an interface (_Use Case Output Port_) in the inner circle, and have the presenter in the outer circle implement it.

The same technique is used to cross al the boundaries in the architectures. We take advantage of dynamic polymorphism to create source code dependencies that oppose thw flow of control so that we can conform to _The Dependency Rule_ no matter what direction the flow of control is going in.

## What Data Crosses the Boundaries

Typically the data that crosses the boundaries is simple data structures. You can use basic structs or _Data Transfer_ objects if you like. The important thing is that __isolated, simple, data structures are passed across the boundaries__. We don't want the data to have any kind of dependency that violates _The Dependency Rule_.

For example, many database frameworks return a convenient data format in response to a query. We might call this a `RowStructure`. We don't want to pass that row structure inwards across a boundary. That would violate _The Dependency Rule_ because it would force an inner circle to know something about an outer circle.

So when we pass data across a boundary, __it is always in the form that is most convenient for the inner circle__.
